# 二分查找

目标：在数组中快速找出指定元素。

假设你有一个数字数组，你想知道某个特定的数字是否存在于这个数组里，如果存在的话，找到它的下标。

在绝大多数情况下，Swift 的 `Collection.index(of:)` 方法已经足够好用了：

```swift
let numbers = [11, 59, 3, 2, 53, 17, 31, 7, 19, 67, 47, 13, 37, 61, 29, 43, 5, 41, 23]

numbers.index(of: 43)  // 返回 15
```

这个内建的 `Collection.index(of:)` 方法使用了[线性查找](../Linear%20Search/)。用代码来表示就会是这样的：

```swift
func linearSearch<T: Equatable>(_ a: [T], _ key: T) -> Int? {
    for i in 0 ..< a.count {
        if a[i] == key {
            return i
        }
    }
    return nil
}
```

然后你可以这样调用它：

```swift
linearSearch(numbers, 43)  // 返回 15
```

那么这有什么问题呢？`linearSearch()` 从头遍历了整个数组，直到它找到目标元素。在最坏的情况下，你要找的数字不在数组里，于是整个遍历都白忙活了。

在平均情况下，线性查找算法需要遍历数字中一半的元素。如果你的数组足够大，这就需要相当长的时间！

## 分治法

*二分查找*就是为了给这种情况提速的一个经典的方案。它的关键在于不断把数组对半分，直到找到想要的数值。

对于一个长度为 `n` 的数组，它的复杂度是比线性查找的 **O(n)** 要小的 **O(log n)**。具体来说，对于拥有 1,000,000 个元素的数组进行二分查找，只需要20步左右就能找到目标，因为 `log_2(1,000,000) = 19.9`。而对于拥有10亿个元素的数组，它只需要30步。（不过话说回来，你什么时候用到过有10亿个元素的数组？）

看起来不错，但是二分查找也有它的缺点：数组必须是有序的。实际应用上，这通常也不是什么问题。

二分查找的运行逻辑是这样的：

- 将数组对半分成左右两个部分，然后看看你要查找的目标，也叫做*搜索关键字*，是在左半边还是右半边。
- 你怎么知道搜索关键字在哪个半边呢？这就是为什么要先给数组排序了，这样你就能用简单的 `<` 或 `>` 来进行比较。
- 如果搜索关键字在左半边，你就在这边执行同样的操作：将这个半边再次对半分成两个更小的部分，然后看看搜索关键字在哪个半边。（对于在右边的情况也是一样的）
- 一直重复动作直到搜索关键字被找出来。如果数组已经没办法继续拆分，那么很可惜，你只能给出结论：搜索关键字不在数组里。

现在你应该知道它为什么叫“二分”查找了：它每次都会把数组分成相等长度的两半。这种“分治”的方法就是它能快速缩小搜索关键字所在范围的秘诀。

## 代码

下面是用 Swift 基于递归实现的二分查找：

```swift
func binarySearch<T: Comparable>(_ a: [T], key: T, range: Range<Int>) -> Int? {
    if range.lowerBound >= range.upperBound {
        // 如果来到了这里，那就说明搜索关键字不在数组里
        return nil

    } else {
        // 计算在哪里拆分数组
        let midIndex = range.lowerBound + (range.upperBound - range.lowerBound) / 2

        // 搜索关键字在左半边吗？
        if a[midIndex] > key {
            return binarySearch(a, key: key, range: range.lowerBound ..< midIndex)

        // 搜索关键字在右半边吗？
        } else if a[midIndex] < key {
            return binarySearch(a, key: key, range: midIndex + 1 ..< range.upperBound)

        // 如果来到了这里，那我们就找到搜索关键字啦！
        } else {
            return midIndex
        }
    }
}
```

来试试看，把代码复制到 playground 里，然后执行：

```swift
let numbers = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67]

binarySearch(numbers, key: 43, range: 0 ..< numbers.count)  // 返回 13
```

需要注意 `numbers` 数组是有序的。不然二分查找算法就失灵了！

虽然上面说二分查找要把数组分成两半，但我们并没有真的去创建两个新数组。而是通过 Swift 的 `Range` 对象来跟踪这些分段。在算法的开始，跟踪范围覆盖了整个数组，`0 ..< numbers.count`。随着我们不断拆分数组，这个范围就变得越来越小了。

> **注意：**有一点需要额外关注，`range.upperBound` 一直指向最后一个元素的下一位。在上面的例子中，这个范围是 `0..<19`，因为数组里有19个数字，所以 `range.lowerBound = 0` 并且 `range.upperBound = 19`。然而在我们的数字里，最后一个元素的下标是18，而不是19，因为我们是从0开始计算的。总而言之，在使用范围的时候：`upperBound` 永远比最后一个元素的下标多1。

## 一步步解读示例

了解算法运行的细节是很有意义的。

例子里的数组里有19个数字，它是长这个样子的：

	[ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67 ]

我们要尝试判断 `43` 这个数字是否在数组里。

为了把数组对半分，我们需要知道位于中间的那个对象的下标。下面这行代码就是这个作用：

```swift
let midIndex = range.lowerBound + (range.upperBound - range.lowerBound) / 2
```

一开始，这个范围是 `lowerBound = 0` 和 `upperBound = 19`。把这两个数填进去，我们就可以得出 `midIndex` 是 `0 + (19 - 0)/2 = 19/2 = 9`。其实它应该是 `9.5`，但因为我们用的是整型，所以结果被向下取整了。

我们用 `*` 来标志中间对象。可以看到，标志两边的元素个数是一样的，说明我们正好把数组对半分开了。

	[ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67 ]
                                      *

接下来，二分查找需要判断对哪一半继续执行算法。这个逻辑在代码里的体现如下：

```swift
if a[midIndex] > key {
    // 用左半边
} else if a[midIndex] < key {
    // 用右半边
} else {
    return midIndex
}
```

在这个情况下，`a[midIndex] = 29`。这个结果比搜索关键字要小，所以我们可以放心大胆地给出结论：搜索关键字绝对不会在数组的左半边。毕竟左半边的数字只会比 `29` 更小。因此，搜索关键字应该要在右半边（或者就根本不在数组里）。

现在我们就可以重复执行二分查找，不同的是，执行的区间换成了数组里的 `midIndex + 1` 到 `range.upperBound`：

	[ x, x, x, x, x, x, x, x, x, x | 31, 37, 41, 43, 47, 53, 59, 61, 67 ]

因为我们已经不管数组的左半边的内容了，所以这里把它们都标记成了 `x`。从现在开始，我们只会在数组的右半边进行查找，也就是从数组下标为 `10` 的位置开始。

我们先计算出新的中位元素：`midIndex = 10 + (19 - 10)/2 = 14`，然后再次把数组从中间分开。

	[ x, x, x, x, x, x, x, x, x, x | 31, 37, 41, 43, 47, 53, 59, 61, 67 ]
	                                                 *

如上所示，`a[14]` 是数组右半边的中间元素。

搜索关键字比 `a[14]` 大还是小呢？因为 `43 < 47` 所以是更小的。这次我们就要在左半边继续，舍弃掉右半边那些比它大的数字：

	[ x, x, x, x, x, x, x, x, x, x | 31, 37, 41, 43 | x, x, x, x, x ]

新的 `midIndex` 在这里：

	[ x, x, x, x, x, x, x, x, x, x | 31, 37, 41, 43 | x, x, x, x, x ]
	                                     *

搜索关键字比 `37` 大，所以取右半边继续：

	[ x, x, x, x, x, x, x, x, x, x | x, x | 41, 43 | x, x, x, x, x ]
	                                        *

再来，搜索关键字还是比较大，所以再对半分，然后取右半边：

	[ x, x, x, x, x, x, x, x, x, x | x, x | x | 43 | x, x, x, x, x ]
	                                            *

然后就完事儿了。搜索关键字与数组中的元素相等了，于是我们就找到了目标：数字 `43` 在数组下标为 `13` 的位置。耶✌️！

这工作量看起来好像挺大的，但事实上算法只运行了4个步骤就找到了搜索关键字，这也符合我们的预期，因为 `log_2(19) = 4.23`。如果用线性查找，那就需要 14 步才能完成。

如果我们要找的不是 `43` 而是 `42` 会发生什么呢？这个时候，我们就没法继续拆分数组了。`range.upperBound` 会变得比 `range.lowerBound` 更小。这就告诉了算法搜索关键字不在数组里，然后它就会返回 `nil`。

> **注意：**有不少二分查找的实现会用 `midIndex = (lowerBound + upperBound) / 2` 来计算中间下标。这个做法隐藏了一个只在超级大的数组中才会出现的 bug，因为 `lowerBound + upperBound` 有可能超过一个整型数据能保存的最大值。在 64 位的 CPU 上不太可能出现这个问题，但在 32 位的机器上就非常难说了。

## 迭代 vs 递归

二分查找天生就很适合递归，因为它需要不断对越来越小的子数组执行相同的逻辑处理。但这并不意味着你必须要把 `binarySearch()` 实现成一个递归方法。通常，把一个递归算法转换成迭代的版本会更加高效，也就是用简单的循环取代一系列的递归调用。

下面是用 Swift 实现的迭代版的二分查找：

```swift
func binarySearch<T: Comparable>(_ a: [T], key: T) -> Int? {
    var lowerBound = 0
    var upperBound = a.count
    while lowerBound < upperBound {
        let midIndex = lowerBound + (upperBound - lowerBound) / 2
        if a[midIndex] == key {
            return midIndex
        } else if a[midIndex] < key {
            lowerBound = midIndex + 1
        } else {
            upperBound = midIndex
        }
    }
    return nil
}
```

如上所示，这段代码跟递归版的代码很像。最大的区别在于 `while` 循环的使用上。

这个方法可以这样使用：

```swift
let numbers = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67]

binarySearch(numbers, key: 43)  // 返回 13
```

## 尾声

数组必须有序会是个大问题吗？看情况。要知道，排序也是需要时间的，二分查找加上排序的时间可能比简单的线性查找要长。如果排序一次之后会用来查找好几次，那二分查找的优势就来了。

你可以参考看看[维基百科](https://en.wikipedia.org/wiki/Binary_search_algorithm)。

*原文出自 Matthijs Hollemans*