# 插入排序

目标：将数组里的元素从小到大（或从大到小）排序。

你现在需要对一组数字进行排序。插入排序算法的运行逻辑是这样的：

- 先把数字都放到一边，这堆数字是无序的。
- 从这堆数字里选出一个。怎么选无关紧要，不过最简单的方式还是直接取最顶上的那个。
- 将这个数字插入到一个新数组中。
- 从刚才那堆数字里再选出一个并插入到这个新数组里。按照你的排序需求，把这个数字插入到上一个数字的前面或后面，现在这两个数字就是有序的了。
- 再来一次，从数字堆里选出一个数字并插入到数组的合适位置。
- 不断重复这个步骤，直到那堆数字已经取完。你最后会得到一个空的数字堆和一个有序的数组。

这就是为什么这个算法叫“插入”排序，因为你从一堆无序的数字里取出数字并插入到数组的合适位置。

## 一个例子

假设我们要排序的数字是 `[ 8, 3, 5, 4, 6 ]`。这就是我们的无序数字堆。

选出第一个数字，`8`，然后把它插入到新的数组里。那个数组目前是空的，所以这个操作很简单。现在数组是 `[8]` 而那堆数字就变成了 `[ 3, 5, 4, 6 ]`。

从数字堆里选出下一个数字，`3`，并把它插入到有序的数组里。这个数字应该排在 `8` 的前面，所以有序数组就变成 `[ 3, 8 ]` 而那堆数字就变成 `[ 5, 4, 6 ]`。

从数字堆里选出下一个数字，`5`，并把它插入到有序的数组里。这个数字应该排在 `3` 和 `8` 之间。有序数组变成 `[ 3, 5, 8 ]` 而那堆数字就变成 `[ 4, 6 ]`。

重复这个过程直到那堆数字空掉。

## 原地排序

上述流程看起来好像需要用到两个数组：一个存放着一堆无序的数字，另一个则存放着已经排好序的数字。

事实上你可以在 *原地* 进行插入排序，不需要额外创建一个数组。你只需要记住数组里已经排好序的和无序的部分在哪里。

初始状态下，这个数组是 `[ 8, 3, 5, 4, 6 ]`。我们用 `|` 符号来表示有序部分和无序部分的间隔：

	[| 8, 3, 5, 4, 6 ]

这表示有序部分是空的，而那堆无序的数字是从 `8` 开始往后的。

在处理完第一个数字之后，我们得到了这个数组：

	[ 8 | 3, 5, 4, 6 ]

有序部分是 `[ 8 ]`，无序部分是 `[ 3, 5, 4, 6 ]`。分隔符号 `|` 往右边移动了一个位置。

下面是排序过程中数组的变化结果：

	[| 8, 3, 5, 4, 6 ]
	[ 8 | 3, 5, 4, 6 ]
	[ 3, 8 | 5, 4, 6 ]
	[ 3, 5, 8 | 4, 6 ]
	[ 3, 4, 5, 8 | 6 ]
	[ 3, 4, 5, 6, 8 |]

在每一步里，分隔符 `|` 都会向前移动一个位置。正如你所见，数组中从开头到 `|` 的部分一直都是有序的。那堆无序的数字每次都会减少一个，而有序部分的数组每次都会增加一个，直到无序部分里一个数字也不剩。

## 怎么插入

排序过程中的每一步你都会从无序数字堆里取出一个，然后插入到数组的有序部分里。你必须要把数字插入到恰当的位置，以保证数组的开头部分是有序的。这是怎么做到的呢？

假设我们已经完成了几个数字的排序，现在数组是这样的：

	[ 3, 5, 8 | 4, 6 ]

下一个要进行排序的数字是 `4`。我们要把它插入到 `[ 3, 5, 8 ]` 这个部分的某个位置。

其中一种方式是这样的：查看它前一位的数字，`8`。

	[ 3, 5, 8, 4 | 6 ]
	        ^
	        
它比 `4` 更大吗？是的，所以 `4` 应该排在 `8` 的前面。于是我们交换这两个数字的位置：

	[ 3, 5, 4, 8 | 6 ]
	        <-->
	        交换了

还没有结束。前一个位置的数字变成了 `5`，还是比 `4` 更大。我们继续交换它们位置：

	[ 3, 4, 5, 8 | 6 ]
	     <-->
	     交换了

再次查看前一位的数字。`3` 比 `4` 更大吗？不是了。这说明我们已经完成了对 `4` 的排序。数组的开头部分再次恢复成有序的了。

上面的过程描述的是插入排序算法中的内层循环，在下一个小节里你就能看到。它通过交换数字的位置来实现把数组无序部分的数字插入到数组有序部分里。

## 代码

下面是用 Swift 实现的插入排序：

```swift
func insertionSort(_ array: [Int]) -> [Int] {
    var sortedArray = array			 // 1
    for index in 1..<sortedArray.count {		 // 2
        var currentIndex = index
        while currentIndex > 0 && sortedArray[currentIndex] < sortedArray[currentIndex - 1] { // 3
            sortedArray.swapAt(currentIndex - 1, currentIndex)
            currentIndex -= 1
        }
    }
    return sortedArray
}
```

把这段代码放到 playground 就可以像这样来验证它：

```swift
let list = [ 10, -1, 3, 9, 2, 27, 8, 5, 1, 3, 0, 26 ]
insertionSort(list)
```

这段代码的原理如下。

1. 拷贝原数组。这一步是必要的，因为我们不能直接修改作为参数传进来的 `array`。就像 Swift 自己的 `sorted()` 方法那样，这个 `insertionSort()` 方法会返回一个原数组的有序的*备份*。

2. 这个方法里有两个循环。外层循环对数组进行了遍历，作用是从无序数字堆里取出数字。变量 `currentIndex` 记录了有序部分的结尾和无序部分的开头（也就是分隔符 `|` 所在的位置）。要记住，在算法执行的任何时间点，数组从下标为0的起始位置到 `currentIndex` 标记的位置的部分都是有序的。其余部分，从 `currentIndex` 到数组结尾，就是那堆无序的数字。

3. 内层循环负责给 `currentIndex` 对应的元素排序。这是无序数字里的第一个，而它有可能比它前面的任意一个数字小。内层循环会反向遍历数组的有序部分，每次它发现前一个数字更大都会交换数字的位置。在内层循环结束后，数组的开头部分又再次恢复有序，而且有序数字的个数也会加一。

> **注意：**外层循环是从1开始的，不是0。对第一个数字进行排序不会改变任何东西，所以我们跳过这一步也无妨。

## 别再交换了

上述版本的插入排序是能用的，但我们可以通过去掉 `swap()` 的调用来让算法更快一点点。

你已经见过算法是如何把数字通过交换插入到有序部分的：

	[ 3, 5, 8, 4 | 6 ]
	        <-->
            交换
	        
	[ 3, 5, 4, 8 | 6 ]
         <-->
	     交换

除了不断往前交换以外，我们还可以把前方的数字逐个往右移动一个位置，然后把新的数字拷贝到它应该去的地方。

	[ 3, 5, 8, 4 | 6 ]   记住这个 4
	           *
	
	[ 3, 5, 8, 8 | 6 ]   将 8 往右移动
	        --->
	        
	[ 3, 5, 5, 8 | 6 ]   将 5 往右移动
	     --->
	     
	[ 3, 4, 5, 8 | 6 ]   把 4 拷贝到它该去的位置
	     *

用代码来表示就是：

```swift
func insertionSort(_ array: [Int]) -> [Int] {
  var sortedArray = array
  for index in 1..<sortedArray.count {
    var currentIndex = index
    let temp = sortedArray[currentIndex]
    while currentIndex > 0 && temp < sortedArray[currentIndex - 1] {
      sortedArray[currentIndex] = sortedArray[currentIndex - 1]                // 1
      currentIndex -= 1
    }
    sortedArray[currentIndex] = temp                      // 2
  }
  return sortedArray
}
```

`//1` 标记的那行代码就是用来把数字往右移动一个位置的。内层循环结束时，`currentIndex` 就是新数字所要去的位置，然后 `//2` 标记的那行代码就会把它拷贝过去。

## 让它更通用

如果能对数字以外的东西进行排序就好了。我们可以使用泛型来声明数组的元素类型，然后让用户提供一个方法（或闭包）对元素进行排序。现在我们只需要在原来的代码上改动两个地方。

方法前面变成这样：

```swift
func insertionSort<T>(_ array: [T], _ isOrderedBefore: (T, T) -> Bool) -> [T] {
```

数组的类型改为 `[T]`，其中 `T` 是泛型类型的占位符。现在 `insertionSort()` 就能接受任意类型的数组了，不管数组里的元素是数字、字符串还是别的什么东西。

新的参数 `isOrderedBefore: (T, T) -> Bool` 是一个用来排序的方法，它接受两个 `T` 类型的对象，如果第一个对象排在第二个对象的前面则返回 `true`，反之则返回 `false`。这种处理方式跟 Swift 内置的 `sort()` 方法是一样的。

另一处要改动的地方在内循环里，要改成这样：

```swift
      while currentIndex > 0 && isOrderedBefore(temp, sortedArray[currentIndex - 1]) {
```

把原来的 `temp < sortedArray[currentIndex - 1]` 改为调用 `isOrderedBefore()` 方法。它们的作用是一样的，不过现在我们可以对任意类型的对象进行排序，而不只是数字了。

要在 playground 里测试的话，可以这样写：

```swift
let numbers = [ 10, -1, 3, 9, 2, 27, 8, 5, 1, 3, 0, 26 ]
insertionSort(numbers, <)
insertionSort(numbers, >)
```

传入方法的参数 `<` 和 `>` 决定了排序的方向，分别是从小到大和从大到小。

当然了，你还可以对其他类型进行排序，比如字符串：

```swift
let strings = [ "b", "a", "d", "c", "e" ]
insertionSort(strings, <)
```

甚至是一些更复杂的对象：

```swift
let objects = [ obj1, obj2, obj3, ... ]
insertionSort(objects) { $0.priority < $1.priority }
```

这个闭包告诉 `insertionSort()` 根据对象里的 `priority` 属性来排序。

插入排序是一种稳定排序。所谓的稳定是指：拥有相同排序关键字的元素在排序前后的相对位置不会被改变。这一点对于简单的数值型元素来说不太重要，比如数字或者字符串；但当我们要给复杂对象排序时，如果两个对象有着相同的 `priority` 属性，那么不管它们其他属性的值是什么，它们都不会交换彼此的位置。

## 性能

插入排序在数组已经有序时是很快的。这听起来像是一句废话，但并不是所有的搜索算法都是这样的。在实际情况下，绝大部分数据都已经是有序的（也可能是全部有序），这个时候插入排序的性能就很好。

插入排序的最坏情况和平均情况的复杂度是 **O(n^2)**。这是因为算法里有两层循环。其他排序算法，比如快速排序和归并排序，有着 **O(n log n)** 的复杂度，这在处理大量数据的时候算是很快的。

插入排序在处理少量数据的时候是比较好的选择。在一些标准库里，排序方法会在数组长度小于10的时候，把算法从快速排序切换成插入排序。

我对 `insertionSort()` 和 Swift 内置的 `sort()` 进行了一次简单的比较。当数组长度在100左右的时候，它们速度上的差异非常小。然而，随着数组长度的递增，**O(n^2)** 复杂度相较于 **O(n log n)** 复杂度的劣势就迅速体现出来了，插入排序的性能就开始跟不上了。

## 相关信息

[维基百科上的插入排序](https://en.wikipedia.org/wiki/Insertion_sort)

*原文出自 Matthijs Hollemans*
